/*
 * Copyright 2018-2022 Copenhagen Center for Health Technology (CACHET) at the
 * Technical University of Denmark (DTU).
 * Use of this source code is governed by a MIT-style license that can be
 * found in the LICENSE file.
 */

part of runtime;

class TriggerEvent {
  // TriggerConfiguration? trigger;
}

// ---------------------------------------------------------------------------------------------------------
// TRIGGER EXECUTORS
// ---------------------------------------------------------------------------------------------------------

/// Responsible for handling the execution of a trigger.
///
/// This is an abstract class. For each specific type of [TriggerConfiguration],
/// a corresponding implementation of this class exists.
abstract class TriggerExecutor<TConfig extends TriggerConfiguration>
    extends AbstractExecutor<TConfig> {
  final StreamController<TriggerEvent> _controller =
      StreamController.broadcast();

  /// The stream of events triggered from this trigger executor.
  Stream<TriggerEvent> get triggerEvents => _controller.stream;

  // a lot of trigger executors use a timer, so we declare one here
  Timer? _timer;

  @override
  Stream<Measurement> get measurements => const Stream.empty();

  // Default operations is to do nothing in the following life-cycle methods.
  // Overridden in subclasses, if needed.

  @override
  bool onInitialize() => true;

  @override
  Future<bool> onStart() async => true;

  @override
  Future<bool> onRestart() async => true;

  @override
  Future<bool> onStop() async {
    _timer?.cancel();
    return true;
  }

  /// Called when this trigger executor is triggering.
  @mustCallSuper
  Future<void> onTrigger() async => _controller.add(TriggerEvent());
}

/// Abstract class for executors of triggers which can be scheduled
/// (i.e., implementing the [Schedulable] interface).
abstract class SchedulableTriggerExecutor<TConfig extends TriggerConfiguration>
    extends TriggerExecutor<TConfig> {
  /// An ordered list of timestamp generated by this trigger for a
  /// given period. This is mainly used for persistently scheduling
  /// a list of [AppTask]s from triggers that implement the [Schedulable]
  /// interface.
  List<DateTime> getSchedule(DateTime from, DateTime to, [int max]);
}

/// Executes an [NoOpTrigger], i.e. does nothing.
class NoOpTriggerExecutor extends TriggerExecutor<TriggerConfiguration> {}

/// Executes an [ImmediateTrigger], i.e. starts sampling immediately.
class ImmediateTriggerExecutor extends TriggerExecutor<TriggerConfiguration> {
  @override
  Future<bool> onStart() async {
    onTrigger();
    return true;
  }
}

/// Executes a [OneTimeTrigger], i.e. a trigger that only runs once during a
/// study deployment.
class OneTimeTriggerExecutor extends TriggerExecutor<OneTimeTrigger> {
  @override
  Future<bool> onStart() async {
    if (!configuration!.hasBeenTriggered) {
      configuration!.triggerTimestamp = DateTime.now();
      onTrigger();
    } else {
      warning(
          "$runtimeType - one time trigger already occurred at: ${configuration?.triggerTimestamp}. "
          'Will not trigger now.');
      return false;
    }
    return true;
  }
}

/// Executes a [PassiveTrigger].
class PassiveTriggerExecutor extends TriggerExecutor<PassiveTrigger> {
  PassiveTriggerExecutor() : super() {
    configuration!.executor = ImmediateTriggerExecutor();
  }

  // Forward to the embedded trigger executor
  @override
  bool onInitialize() {
    configuration!.executor
        .initialize(configuration as TriggerConfiguration, deployment!);
    return true;
  }
}

/// Executes a [DelayedTrigger], i.e. triggers after the specified delay.
class DelayedTriggerExecutor extends TriggerExecutor<DelayedTrigger> {
  @override
  Future<bool> onStart() async {
    _timer = Timer(configuration!.delay, () => onTrigger());
    return true;
  }
}

/// Executes a [ElapsedTimeTrigger], i.e. triggers after the
/// specified delay after deployment start on this phone.
class ElapsedTimeTriggerExecutor
    extends SchedulableTriggerExecutor<ElapsedTimeTrigger> {
  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int? max]) {
    if (deployment?.deployed == null) return [];
    final dd = deployment!.deployed!.add(configuration!.elapsedTimeAsDuration);
    return (dd.isAfter(from) && dd.isBefore(to)) ? [dd] : [];
  }

  @override
  Future<bool> onStart() async {
    if (deployment?.deployed == null) {
      warning(
          '$runtimeType >> this deployment does not have a start time. Cannot execute this trigger.');
      return false;
    } else {
      int delay = configuration!.elapsedTimeAsDuration.inMilliseconds -
          (DateTime.now().millisecondsSinceEpoch -
              deployment!.deployed!.millisecondsSinceEpoch);

      if (delay > 0) {
        _timer = Timer(Duration(milliseconds: delay), () => onTrigger());
      } else {
        warning(
            '$runtimeType - the trigger time is in the past and should have happened already.');
        return false;
      }
    }

    return true;
  }
}

/// Executes a [PeriodicTrigger].
class PeriodicTriggerExecutor
    extends SchedulableTriggerExecutor<PeriodicTrigger> {
  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
    final List<DateTime> schedule = [];
    DateTime timestamp = from;
    int count = 0;

    while (timestamp.isBefore(to) && count < max) {
      schedule.add(timestamp);
      timestamp = timestamp.add(configuration!.period);
      count++;
    }

    return schedule;
  }

  @override
  Future<bool> onStart() async {
    _timer = Timer.periodic(configuration!.period, (t) {
      onTrigger();
    });
    return true;
  }
}

/// Executes a [DateTimeTrigger] on the specified date and time.
class DateTimeTriggerExecutor
    extends SchedulableTriggerExecutor<DateTimeTrigger> {
  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int? max]) =>
      (configuration!.schedule.isAfter(from) &&
              configuration!.schedule.isBefore(to))
          ? [configuration!.schedule]
          : [];

  @override
  Future<bool> onStart() async {
    if (configuration!.schedule.isAfter(DateTime.now())) {
      warning('The schedule of the DateTimeTrigger cannot be in the past.');
      return false;
    } else {
      var delay = configuration!.schedule.difference(DateTime.now());
      _timer = Timer(delay, () => onTrigger());
    }
    return true;
  }
}

/// Executes a [RecurrentScheduledTrigger].
class RecurrentScheduledTriggerExecutor
    extends SchedulableTriggerExecutor<RecurrentScheduledTrigger> {
  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
    List<DateTime> schedule = [];
    DateTime timestamp = configuration!.firstOccurrence;
    int count = 0;

    while (timestamp.isBefore(to) && count < max) {
      if (timestamp.isAfter(from)) schedule.add(timestamp);
      timestamp = timestamp.add(configuration!.period);
      count++;
    }

    return schedule;
  }

  @override
  Future<bool> onStart() async {
    Duration delay = configuration!.firstOccurrence.difference(DateTime.now());
    if (configuration!.end == null ||
        configuration!.end!.isAfter(DateTime.now())) {
      _timer = Timer(delay, () async => onTrigger());
    }
    return true;
  }
}

/// Executes a [CronScheduledTrigger] based on the specified cron job.
class CronScheduledTriggerExecutor
    extends SchedulableTriggerExecutor<CronScheduledTrigger> {
  late cron.Cron _cron;
  cron.ScheduledTask? _task;

  CronScheduledTriggerExecutor() : super() {
    _cron = cron.Cron();
  }

  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
    var cronIterator = Cron().parse(
        configuration!.cronExpression,
        Settings().timezone,
        tz.TZDateTime.from(from, tz.getLocation(Settings().timezone)));
    final List<DateTime> schedule = [];
    int count = 0;

    while (cronIterator.next().isBefore(to) && count < max) {
      schedule.add(cronIterator.current());
      count++;
    }
    return schedule;
  }

  @override
  Future<bool> onStart() async {
    debug('creating cron job : $configuration');
    var schedule = cron.Schedule.parse(configuration!.cronExpression);
    _task = _cron.schedule(schedule, () async {
      debug('resuming cron job : ${DateTime.now().toString()}');
      onTrigger();
    });
    return true;
  }

  @override
  Future<bool> onStop() async {
    _task?.cancel();
    return true;
  }
}

/// Executes a [SamplingEventTrigger] based on the specified
/// [SamplingEventTrigger.measureType] and [SamplingEventTrigger.triggerCondition].
class SamplingEventTriggerExecutor
    extends TriggerExecutor<SamplingEventTrigger> {
  StreamSubscription<Measurement>? _subscription;

  @override
  Future<bool> onStart() async {
    _subscription = SmartPhoneClientManager()
        .lookupStudyRuntime(deployment!.studyDeploymentId,
            deployment!.deviceConfiguration.roleName)
        ?.measurementsByType(configuration!.measureType)
        .listen((measurement) {
      if ((configuration!.triggerCondition != null) &&
          measurement.data.equivalentTo(configuration!.triggerCondition!)) {
        onTrigger();
      }
    });
    return true;
  }

  @override
  Future<bool> onStop() async {
    _subscription?.cancel();
    return true;
  }
}

/// Executes a [ConditionalSamplingEventTrigger].
class ConditionalSamplingEventTriggerExecutor
    extends TriggerExecutor<ConditionalSamplingEventTrigger> {
  StreamSubscription<Measurement>? _subscription;

  @override
  Future<bool> onStart() async {
    _subscription = SmartPhoneClientManager()
        .lookupStudyRuntime(deployment!.studyDeploymentId,
            deployment!.deviceConfiguration.roleName)
        ?.measurementsByType(configuration!.measureType)
        .listen((measurement) {
      if (configuration!.triggerCondition != null &&
          configuration!.triggerCondition!(measurement)) onTrigger();
    });
    return true;
  }

  @override
  Future<bool> onStop() async {
    _subscription?.cancel();
    return true;
  }
}

/// Executes a [ConditionalPeriodicTrigger].
class ConditionalPeriodicTriggerExecutor
    extends TriggerExecutor<ConditionalPeriodicTrigger> {
  @override
  Future<bool> onStart() async {
    // create a recurrent timer that checks the conditions periodically
    _timer = Timer.periodic(configuration!.period, (_) {
      if (configuration!.triggerCondition != null &&
          configuration!.triggerCondition!()) onTrigger();
    });
    return true;
  }
}

/// Executes a [RandomRecurrentTrigger] triggering N times per day within a
/// defined period of time.
class RandomRecurrentTriggerExecutor
    extends SchedulableTriggerExecutor<RandomRecurrentTrigger> {
  final cron.Cron _cron = cron.Cron();
  List<Timer> _timers = [];

  TimeOfDay get startTime => configuration!.startTime;
  TimeOfDay get endTime => configuration!.endTime;
  int get minNumberOfTriggers => configuration!.minNumberOfTriggers;
  int get maxNumberOfTriggers => configuration!.maxNumberOfTriggers;

  /// Get a random number of samples for the day
  int get numberOfSampling =>
      Random().nextInt(maxNumberOfTriggers) + minNumberOfTriggers;

  /// Get N random times between startTime and endTime
  List<TimeOfDay> get samplingTimes {
    List<TimeOfDay> samplingTimes = [];
    for (int i = 0; i <= numberOfSampling; i++) {
      samplingTimes.add(randomTime);
    }
    debug('Random sampling times: $samplingTimes');
    return samplingTimes;
  }

  /// Get a random time between startTime and endTime
  TimeOfDay get randomTime {
    TimeOfDay randomTime = const TimeOfDay();
    do {
      int randomHour = startTime.hour +
          ((endTime.hour - startTime.hour == 0)
              ? 0
              : Random().nextInt(endTime.hour - startTime.hour));
      int randomMinutes = Random().nextInt(60);
      randomTime = TimeOfDay(hour: randomHour, minute: randomMinutes);
    } while (!(randomTime.isAfter(startTime) && randomTime.isBefore(endTime)));

    return randomTime;
  }

  String get todayString {
    final now = DateTime.now();
    return '${now.year}-${now.month}-${now.day}';
  }

  bool get hasBeenScheduledForToday {
    // fast out if no timestamp is set previously
    if (configuration?.lastTriggerTimestamp == null) return false;

    final now = DateTime.now();
    final midnight = DateTime(now.year, now.month, now.day);
    final sinceLastTime =
        now.millisecond - configuration!.lastTriggerTimestamp!.millisecond;
    final sinceMidnight = now.millisecond - midnight.millisecond;

    return (sinceLastTime < sinceMidnight);
  }

  @override
  List<DateTime> getSchedule(DateTime from, DateTime to, [int max = 100]) {
    assert(to.isAfter(from));
    final List<DateTime> schedule = [];

    final startDay = DateTime(from.year, from.month, from.day);
    final toDay = DateTime(to.year, to.month, to.day);
    var day = startDay;
    var count = 0;

    while (day.isBefore(toDay) && count < max) {
      for (var time in samplingTimes) {
        final date = DateTime(
            day.year, day.month, day.day, time.hour, time.minute, time.second);
        if (date.isAfter(from) && date.isBefore(to)) schedule.add(date);
      }

      day = day.add(const Duration(days: 1));
      count++;
    }
    return schedule;
  }

  @override
  Future<bool> onStart() async {
    // sampling might be started after [startTime] or the app wasn't running at [startTime]
    // therefore, first check if the random timers have been scheduled for today
    if (TimeOfDay.now().isAfter(startTime)) {
      if (!hasBeenScheduledForToday) {
        debug(
            '$runtimeType - timers has not been scheduled for today ($todayString) - scheduling now');
        _scheduleTimers();
      }
    }

    // set up a cron job that generates the random triggers once pr day at [startTime]
    final cronJob = '${startTime.minute} ${startTime.hour} * * *';
    debug('$runtimeType - creating cron job : $cronJob');

    _cron.schedule(cron.Schedule.parse(cronJob), () async {
      debug('$runtimeType - resuming cron job : ${DateTime.now().toString()}');
      _scheduleTimers();
    });
    return true;
  }

  void _scheduleTimers() {
    // empty the list of timers.
    _timers = [];

    // get a random number of trigger times for today, and for each set up a
    // timer that triggers the super.onTrigger() method.
    for (var time in samplingTimes) {
      // find the delay - note, that none of the delays can be negative,
      // since we are at [startTime] or after
      Duration delay = time.difference(TimeOfDay.now());
      debug('$runtimeType - setting up timer for : $time, delay: $delay');
      Timer timer = Timer(delay, () async => onTrigger());
      _timers.add(timer);
    }

    // mark this day as scheduled
    configuration!.lastTriggerTimestamp = DateTime.now();
  }
}

/// Executes a [UserTaskTrigger].
class UserTaskTriggerExecutor extends TriggerExecutor<UserTaskTrigger> {
  StreamSubscription<UserTask>? _subscription;

  @override
  Future<bool> onStart() async {
    // listen for event of the specified type and trigger as needed
    _subscription = AppTaskController().userTaskEvents.listen((userTask) async {
      if (userTask.task.name == configuration!.taskName &&
          userTask.state == configuration!.triggerCondition) {
        onTrigger();
      }
    });
    return true;
  }

  @override
  Future<bool> onStop() async {
    _subscription?.cancel();
    return true;
  }
}
